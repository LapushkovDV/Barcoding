using System;
using System.Collections.Concurrent;
using System.ComponentModel;
using System.Threading;

namespace Galaktika.ESB.Adapter.ERP.Adapter
{
    /// <summary>Способ синхронно и асинхронно запустить делегат.</summary>
    public class ElapsedEventReceiver : ISynchronizeInvoke
    {
        private Thread m_Thread;
        private BlockingCollection<Message> m_Queue = new BlockingCollection<Message>();

        /// <summary>
        /// Инициализация объекта. Внутри создается и стартует поток с высоким приоритетом.
        /// </summary>
        public ElapsedEventReceiver()
        {
            m_Thread = new Thread(Run);
            m_Thread.Priority = ThreadPriority.Highest;
            m_Thread.IsBackground = true;
            m_Thread.Start();
        }

        private void Run()
        {
            while (true)
            {
                Message message = m_Queue.Take();
                message.Return = message.Method.DynamicInvoke(message.Args);
                message.Finished.Set();
            }
        }

        /// <summary>Асинхронно выполняет делегат в созданном потоке</summary>
        /// <param name="method"><see cref="T:System.Delegate" /> делегат метода, который принимает параметры в том же количестве и того же типа что и в <paramref name="args" />. </param>
        /// <param name="args">Массив типа<see cref="T:System.Object" /> для передачи аргументов в метод. Может быть <see langword="null" /> если аргументы не нужны. </param>
        /// <returns> Возвращает <see cref="T:System.IAsyncResult" /> интерфейс, который представляет собой асинхронную операцию начатую вызовом метода.</returns>
        public IAsyncResult BeginInvoke(Delegate method, object[] args)
        {
            Message message = new Message();
            message.Method = method;
            message.Args = args;
            m_Queue.Add(message);
            return message;
        }

        /// <summary>Waits until the process started by calling <see cref="M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])" /> completes, and then returns the value generated by the process.</summary>
        /// <param name="result">An <see cref="T:System.IAsyncResult" /> interface that represents the asynchronous operation started by calling <see cref="M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])" />. </param>
        /// <returns>An <see cref="T:System.Object" /> that represents the return value generated by the asynchronous operation.</returns>
        public object EndInvoke(IAsyncResult result)
        {
            Message message = result as Message;
            if (message != null)
            {
                message.Finished.WaitOne();
                return message.Return;
            }
            throw new ArgumentException("result");
        }

        /// <summary>Synchronously executes the delegate on the thread that created this object and marshals the call to the creating thread.</summary>
        /// <param name="method">A <see cref="T:System.Delegate" /> that contains a method to call, in the context of the thread for the control. </param>
        /// <param name="args">An array of type <see cref="T:System.Object" /> that represents the arguments to pass to the given method. This can be <see langword="null" /> if no arguments are needed. </param>
        /// <returns>An <see cref="T:System.Object" /> that represents the return value from the delegate being invoked, or <see langword="null" /> if the delegate has no return value.</returns>
        public object Invoke(Delegate method, object[] args)
        {
            Message message = new Message();
            message.Method = method;
            message.Args = args;
            m_Queue.Add(message);
            message.State = "Started";
            message.Finished.WaitOne();
            return message.Return;
        }
        /// <summary>Gets a value indicating whether the caller must call <see cref="M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])" /> when calling an object that implements this interface.</summary>
        /// <returns>
        /// <see langword="true" /> if the caller must call <see cref="M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])" />; otherwise, <see langword="false" />.</returns>
        public bool InvokeRequired
        {
            get { return Thread.CurrentThread != m_Thread; }
        }

        private class Message : IAsyncResult
        {
            public Delegate Method;
            public object[] Args;
            public object Return;
            public object State;
            public ManualResetEvent Finished = new ManualResetEvent(false);

            public object AsyncState
            {
                get { return State; }
            }

            public WaitHandle AsyncWaitHandle
            {
                get { return Finished; }
            }

            public bool CompletedSynchronously
            {
                get { return false; }
            }

            public bool IsCompleted
            {
                get { return Finished.WaitOne(0); }
            }
        }
    }
}
